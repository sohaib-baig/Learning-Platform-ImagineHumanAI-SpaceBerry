import { FieldValue } from "firebase-admin/firestore";
import type { firestore } from "firebase-admin";
import { adminDb } from "@/lib/firebase-admin";
import { HOST_BILLING_TIERS, HOST_PLAN_DEFAULT_TIER } from "@/lib/constants";
import type { ClubDoc, HostBillingTier, UserDoc } from "@/types/club";
import type {
  OnboardingClubDraft,
  OnboardingRole,
  OnboardingState,
} from "@/types/onboarding";

const DEFAULT_CLUB_DESCRIPTION =
  "A new space for humans exploring technology and AI together.";
const FALLBACK_CLUB_NAME = "Your First Club";
const MAX_SLUG_ATTEMPTS = 6;
const DEFAULT_HOST_TIER = HOST_PLAN_DEFAULT_TIER;

function resolveTierConfig(tier?: HostBillingTier) {
  if (tier && HOST_BILLING_TIERS[tier]) {
    return HOST_BILLING_TIERS[tier];
  }
  return HOST_BILLING_TIERS[DEFAULT_HOST_TIER];
}

function buildBillingSnapshot(tier?: HostBillingTier) {
  const config = resolveTierConfig(tier);
  return {
    tier: config.tier,
    transactionFeePercent: config.transactionFeePercent,
    softLimits: config.softLimits,
    usage: {
      payingMembers: 0,
      videoUploadsThisMonth: 0,
      bandwidthThisMonthGb: 0,
      streakOverSoftLimitDays: 0,
      streakBelowThresholdDays: 0,
    },
  };
}

type UserWithOnboarding = UserDoc & { onboarding?: OnboardingState };

function userDocRef(uid: string) {
  return adminDb.collection("users").doc(uid);
}

function ensureUserSnapshot(
  data: UserWithOnboarding | undefined
): asserts data is UserWithOnboarding {
  if (!data) {
    throw new Error("User document not found");
  }
}

function dedupeStrings(values: (string | undefined)[]): string[] {
  return Array.from(
    new Set(values.filter((value): value is string => Boolean(value)))
  );
}

function fallbackClubName(displayName?: string): string {
  if (!displayName?.trim()) {
    return FALLBACK_CLUB_NAME;
  }
  const firstName = displayName.trim().split(" ")[0];
  if (!firstName) {
    return FALLBACK_CLUB_NAME;
  }
  return `New Club by ${firstName}`;
}

function sanitizeClubName(
  rawName: string | null | undefined,
  autoGenerate: boolean | undefined,
  displayName?: string
) {
  const trimmed = rawName?.trim();
  if (autoGenerate || !trimmed) {
    return { name: fallbackClubName(displayName), autoGenerated: true };
  }
  return { name: trimmed, autoGenerated: false };
}

function sanitizeDescription(value?: string | null, existing?: string): string {
  const trimmed = value?.trim();
  if (trimmed && trimmed.length > 0) {
    return trimmed.slice(0, 1000);
  }
  if (existing?.trim()?.length) {
    return existing.trim();
  }
  return DEFAULT_CLUB_DESCRIPTION;
}

function slugifyName(value: string): string {
  const slug = value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .replace(/--+/g, "-")
    .slice(0, 60);
  return slug.length ? slug : "club";
}

async function ensureUniqueSlug(
  tx: firestore.Transaction,
  desiredSlug: string
): Promise<string> {
  const baseSlug = desiredSlug || "club";
  let candidate = baseSlug;
  let attempt = 0;

  while (attempt < MAX_SLUG_ATTEMPTS) {
    const query = adminDb
      .collection("clubs")
      .where("info.slug", "==", candidate)
      .limit(1);
    const snapshot = await tx.get(query);
    if (snapshot.empty) {
      return candidate;
    }
    attempt += 1;
    candidate = `${baseSlug}-${Math.random().toString(36).slice(2, 6)}`;
  }

  return `${baseSlug}-${Date.now().toString(36)}`;
}

function buildProgressUpdate(
  current: OnboardingState["progress"],
  nextStep?: string
) {
  const progress: Record<string, unknown> =
    typeof current === "object" ? { ...current } : {};

  if (!progress.startedAt) {
    progress.startedAt = FieldValue.serverTimestamp();
  }

  if (nextStep) {
    progress.currentStep = nextStep;
    progress.lastStepCompletedAt = FieldValue.serverTimestamp();
  }

  return progress;
}

function buildDraftRecord(
  current: OnboardingClubDraft | undefined
): Record<string, unknown> {
  return typeof current === "object" ? { ...current } : {};
}

export async function setOnboardingRole(
  uid: string,
  role: OnboardingRole
): Promise<OnboardingState | null> {
  const ref = userDocRef(uid);

  await adminDb.runTransaction(async (tx) => {
    const snap = await tx.get(ref);
    const data = snap.data() as UserWithOnboarding | undefined;
    ensureUserSnapshot(data);

    const existingRoles = data.roles ?? { user: true, host: false };
    const nextRoles = {
      ...existingRoles,
      user: true,
      host: role === "host" ? true : existingRoles.host === true,
    };

    const onboardingUpdate: Record<string, unknown> = {
      ...(data.onboarding ?? {}),
      role,
    };

    onboardingUpdate.progress = buildProgressUpdate(
      data.onboarding?.progress,
      role === "host" ? "host:start" : "member:start"
    );

    tx.update(ref, {
      roles: nextRoles,
      onboarding: onboardingUpdate,
      updatedAt: FieldValue.serverTimestamp(),
    });
  });

  const updated = await ref.get();
  return (updated.data()?.onboarding as OnboardingState) ?? null;
}

interface ClubDraftUpdateInput {
  name?: string | null;
  description?: string | null;
  autoGenerateName?: boolean;
  step?: string;
}

interface HostPlanActivationPayload {
  uid: string;
  clubId: string;
  tier: HostBillingTier;
  stripeCustomerId?: string | null;
  stripeSubscriptionId?: string | null;
}

interface HostPlanCancellationPayload {
  uid: string;
  clubId: string;
  downgradeReason?: string;
}

export async function saveClubDraft(
  uid: string,
  payload: ClubDraftUpdateInput
): Promise<OnboardingState | null> {
  const ref = userDocRef(uid);

  await adminDb.runTransaction(async (tx) => {
    const snap = await tx.get(ref);
    const data = snap.data() as UserWithOnboarding | undefined;
    ensureUserSnapshot(data);

    const currentDraft = buildDraftRecord(data.onboarding?.clubDraft);
    let draftChanged = false;

    if (payload.autoGenerateName || typeof payload.name === "string") {
      const { name, autoGenerated } = sanitizeClubName(
        payload.name,
        payload.autoGenerateName,
        data.displayName
      );
      currentDraft.name = name;
      currentDraft.autoGeneratedName = autoGenerated;
      draftChanged = true;
    }

    if (payload.description !== undefined) {
      currentDraft.description = sanitizeDescription(
        payload.description,
        currentDraft.description as string | undefined
      );
      draftChanged = true;
    }

    if (draftChanged) {
      currentDraft.lastUpdatedAt = FieldValue.serverTimestamp();
    }

    const onboardingUpdate: Record<string, unknown> = {
      ...(data.onboarding ?? {}),
      clubDraft: currentDraft,
    };

    onboardingUpdate.progress = buildProgressUpdate(
      data.onboarding?.progress,
      payload.step
    );

    tx.update(ref, {
      onboarding: onboardingUpdate,
      updatedAt: FieldValue.serverTimestamp(),
    });
  });

  const updated = await ref.get();
  return (updated.data()?.onboarding as OnboardingState) ?? null;
}

export async function createOrReusePlaygroundClub(uid: string): Promise<{
  clubId: string;
  slug: string;
}> {
  let result: { clubId: string; slug: string } | null = null;
  let resolvedTier: HostBillingTier = DEFAULT_HOST_TIER;

  await adminDb.runTransaction(async (tx) => {
    const userRef = userDocRef(uid);
    const snap = await tx.get(userRef);
    const data = snap.data() as UserWithOnboarding | undefined;
    ensureUserSnapshot(data);

    const existingDraft = data.onboarding?.clubDraft;
    const { name } = sanitizeClubName(
      existingDraft?.name,
      existingDraft?.autoGeneratedName,
      data.displayName
    );
    const description = sanitizeDescription(
      existingDraft?.description,
      existingDraft?.description
    );

    let clubId = existingDraft?.clubId;
    let slug = existingDraft?.slug?.trim();
    let clubRef = clubId ? adminDb.collection("clubs").doc(clubId) : null;

    if (clubRef) {
      const clubSnap = await tx.get(clubRef);
      if (!clubSnap.exists) {
        clubId = undefined;
        clubRef = null;
      } else {
        const clubData = clubSnap.data() as ClubDoc;
        if (clubData.hostId !== uid) {
          throw new Error("Club draft references a club you do not own");
        }
        const existingTier =
          (clubData.billingTier as HostBillingTier | undefined) ??
          (clubData.planType as HostBillingTier | undefined) ??
          (data.onboarding?.hostStatus?.billingTier as
            | HostBillingTier
            | undefined) ??
          DEFAULT_HOST_TIER;
        resolvedTier = existingTier;
        const tierConfig = resolveTierConfig(existingTier);
        slug =
          clubData.info.slug ??
          slug ??
          (await ensureUniqueSlug(tx, slugifyName(name)));
        const updatePayload: firestore.UpdateData<firestore.DocumentData> = {
          "info.name": name,
          "info.description": description,
          "info.slug": slug,
          planType: tierConfig.tier,
          billingTier: tierConfig.tier,
          maxMembers: tierConfig.includedPayingMembers,
          memberCost: clubData.memberCost ?? 0,
          updatedAt: FieldValue.serverTimestamp(),
        };

        if (!clubData.billing) {
          updatePayload.billing = buildBillingSnapshot(tierConfig.tier);
        }

        tx.update(clubRef, updatePayload);
      }
    }

    if (!clubRef) {
      const tierConfig = resolveTierConfig(
        (data.onboarding?.hostStatus?.billingTier as
          | HostBillingTier
          | undefined) ?? DEFAULT_HOST_TIER
      );
      resolvedTier = tierConfig.tier;
      const desiredSlug = slugifyName(slug ?? name);
      slug = await ensureUniqueSlug(tx, desiredSlug);
      clubRef = adminDb.collection("clubs").doc();
      clubId = clubRef.id;
      const clubPayload: firestore.DocumentData = {
        info: {
          name,
          slug,
          description,
          vision: "",
          mission: "",
          bannerUrl: "",
          benefits: [],
          price: 0,
          currency: "AUD",
          recommendedClubs: [],
        },
        hostId: uid,
        membersCount: 0,
        planType: tierConfig.tier,
        billingTier: tierConfig.tier,
        billing: buildBillingSnapshot(tierConfig.tier),
        maxMembers: tierConfig.includedPayingMembers,
        memberCost: 0,
        meta: {
          badges: {
            activeHost: false,
            communityBuilder: false,
            featuredByImagineHumans: false,
          },
        },
        createdAt: FieldValue.serverTimestamp(),
        updatedAt: FieldValue.serverTimestamp(),
      };
      tx.set(clubRef, clubPayload);
    }

    const clubsHosted = Array.isArray(data.clubsHosted) ? data.clubsHosted : [];
    const updatedClubsHosted = dedupeStrings([...clubsHosted, clubId]);

    const onboardingUpdate: Record<string, unknown> = {
      ...(data.onboarding ?? {}),
      clubDraft: {
        ...(data.onboarding?.clubDraft ?? {}),
        name,
        description,
        slug,
        clubId,
        billingTier: resolvedTier,
        lastUpdatedAt: FieldValue.serverTimestamp(),
      },
      hostStatus: {
        ...(data.onboarding?.hostStatus ?? {}),
        activated: false,
        pendingActivation: true,
        clubId,
        billingTier: resolvedTier,
      },
    };

    onboardingUpdate.progress = buildProgressUpdate(
      data.onboarding?.progress,
      "host:playground-created"
    );

    tx.update(userRef, {
      clubsHosted: updatedClubsHosted,
      onboarding: onboardingUpdate,
      updatedAt: FieldValue.serverTimestamp(),
    });

    result = { clubId: clubId!, slug: slug! };
  });

  return result!;
}

export async function applyHostPlanActivation({
  uid,
  clubId,
  tier,
  stripeCustomerId,
  stripeSubscriptionId,
}: HostPlanActivationPayload): Promise<void> {
  const tierConfig = resolveTierConfig(tier);
  const userRef = userDocRef(uid);
  const clubRef = adminDb.collection("clubs").doc(clubId);

  await adminDb.runTransaction(async (tx) => {
    const [userSnap, clubSnap] = await tx.getAll(userRef, clubRef);
    const userData = userSnap.data() as UserWithOnboarding | undefined;
    ensureUserSnapshot(userData);
    if (!clubSnap.exists) {
      throw new Error("Club document not found");
    }
    const clubData = clubSnap.data() as ClubDoc;

    if (!clubData.hostId) {
      throw new Error("Club does not have a host assigned");
    }
    if (clubData.hostId !== uid) {
      throw new Error("Cannot activate host plan for a club you do not own");
    }

    const billingPaths: Record<string, unknown> = {
      "billing.tier": tierConfig.tier,
      "billing.transactionFeePercent": tierConfig.transactionFeePercent,
      "billing.softLimits": tierConfig.softLimits,
      "billing.usage": {
        ...(clubData.billing?.usage ?? {}),
        payingMembers: clubData.membersCount ?? 0,
      },
      "billing.upgradeScheduledFor": FieldValue.delete(),
      "billing.downgradeEligibleAfter": FieldValue.delete(),
      "billing.upgradeReason": FieldValue.delete(),
      "billing.warningEmailSentAt": FieldValue.delete(),
    };

    if (stripeCustomerId) {
      billingPaths["billing.stripeCustomerId"] = stripeCustomerId;
    }
    if (stripeSubscriptionId) {
      billingPaths["billing.stripeSubscriptionId"] = stripeSubscriptionId;
    }

    tx.update(clubRef, {
      planType: tierConfig.tier,
      billingTier: tierConfig.tier,
      maxMembers: tierConfig.includedPayingMembers,
      memberCost: clubData.memberCost ?? 0,
      updatedAt: FieldValue.serverTimestamp(),
      ...billingPaths,
    });

    const onboardingHostStatus: Record<string, unknown> = {
      ...(userData.onboarding?.hostStatus ?? {}),
      activated: true,
      pendingActivation: false,
      clubId,
      billingTier: tierConfig.tier,
    };
    if (stripeCustomerId) {
      onboardingHostStatus.stripeCustomerId = stripeCustomerId;
    }
    if (stripeSubscriptionId) {
      onboardingHostStatus.stripeSubscriptionId = stripeSubscriptionId;
    }

    const onboardingUpdate: Record<string, unknown> = {
      ...(userData.onboarding ?? {}),
      hostStatus: onboardingHostStatus,
    };

    onboardingUpdate.progress = buildProgressUpdate(
      userData.onboarding?.progress,
      "host:plan-active"
    );

    const nextHostStatus: Record<string, unknown> = {
      ...(userData.hostStatus ?? {}),
      enabled: true,
      billingTier: tierConfig.tier,
    };
    if (stripeCustomerId) {
      nextHostStatus.stripeCustomerId = stripeCustomerId;
    }
    if (stripeSubscriptionId) {
      nextHostStatus.stripeSubscriptionId = stripeSubscriptionId;
    }

    tx.update(userRef, {
      onboarding: onboardingUpdate,
      hostStatus: nextHostStatus,
      roles: {
        ...(userData.roles ?? { user: true }),
        user: true,
        host: true,
      },
      updatedAt: FieldValue.serverTimestamp(),
    });
  });
}

export async function applyHostPlanCancellation({
  uid,
  clubId,
  downgradeReason = "subscription_cancelled",
}: HostPlanCancellationPayload): Promise<void> {
  const tierConfig = resolveTierConfig(HOST_PLAN_DEFAULT_TIER);
  const userRef = userDocRef(uid);
  const clubRef = adminDb.collection("clubs").doc(clubId);

  await adminDb.runTransaction(async (tx) => {
    const [userSnap, clubSnap] = await tx.getAll(userRef, clubRef);
    const userData = userSnap.data() as UserWithOnboarding | undefined;
    ensureUserSnapshot(userData);

    if (!clubSnap.exists) {
      throw new Error("Club document not found");
    }
    const clubData = clubSnap.data() as ClubDoc;
    if (clubData.hostId !== uid) {
      throw new Error("Cannot cancel host plan for a club you do not own");
    }

    const clubUpdate: firestore.UpdateData<firestore.DocumentData> = {
      planType: tierConfig.tier,
      billingTier: tierConfig.tier,
      maxMembers: tierConfig.includedPayingMembers,
      updatedAt: FieldValue.serverTimestamp(),
      "billing.tier": tierConfig.tier,
      "billing.transactionFeePercent": tierConfig.transactionFeePercent,
      "billing.softLimits": tierConfig.softLimits,
      "billing.usage": {
        ...(clubData.billing?.usage ?? {}),
        payingMembers: clubData.membersCount ?? 0,
      },
      "billing.upgradeScheduledFor": FieldValue.delete(),
      "billing.downgradeEligibleAfter": FieldValue.delete(),
      "billing.upgradeReason": FieldValue.delete(),
      "billing.warningEmailSentAt": FieldValue.delete(),
      "billing.stripeSubscriptionId": FieldValue.delete(),
    };

    if (downgradeReason) {
      clubUpdate["billing.downgradeReason"] = downgradeReason;
    } else {
      clubUpdate["billing.downgradeReason"] = FieldValue.delete();
    }

    tx.update(clubRef, clubUpdate);

    const onboardingHostStatus: Record<string, unknown> = {
      ...(userData.onboarding?.hostStatus ?? {}),
      activated: false,
      pendingActivation: false,
      billingTier: tierConfig.tier,
    };
    onboardingHostStatus.stripeSubscriptionId = FieldValue.delete();
    onboardingHostStatus.upgradeScheduledFor = FieldValue.delete();
    onboardingHostStatus.downgradeEligibleAfter = FieldValue.delete();

    const onboardingUpdate: Record<string, unknown> = {
      ...(userData.onboarding ?? {}),
      hostStatus: onboardingHostStatus,
    };

    onboardingUpdate.progress = buildProgressUpdate(
      userData.onboarding?.progress,
      "host:plan-cancelled"
    );

    const nextHostStatus: Record<string, unknown> = {
      ...(userData.hostStatus ?? {}),
      enabled: false,
      billingTier: tierConfig.tier,
    };
    nextHostStatus.stripeSubscriptionId = FieldValue.delete();

    tx.update(userRef, {
      onboarding: onboardingUpdate,
      hostStatus: nextHostStatus,
      updatedAt: FieldValue.serverTimestamp(),
    });
  });
}

export async function markOnboardingComplete(
  uid: string,
  flow: OnboardingRole
): Promise<OnboardingState | null> {
  const ref = userDocRef(uid);

  await adminDb.runTransaction(async (tx) => {
    const snap = await tx.get(ref);
    const data = snap.data() as UserWithOnboarding | undefined;
    ensureUserSnapshot(data);

    const onboardingUpdate: Record<string, unknown> = {
      ...(data.onboarding ?? {}),
      lastCompletedFlow: flow,
      completedAt: FieldValue.serverTimestamp(),
    };

    onboardingUpdate.progress = buildProgressUpdate(
      data.onboarding?.progress,
      flow === "host" ? "host:complete" : "member:complete"
    );

    tx.update(ref, {
      onboarding: onboardingUpdate,
      updatedAt: FieldValue.serverTimestamp(),
    });
  });

  const updated = await ref.get();
  return (updated.data()?.onboarding as OnboardingState) ?? null;
}
